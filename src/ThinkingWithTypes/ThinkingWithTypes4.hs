{-# LANGUAGE RoleAnnotations #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}

module ThinkingWithTypes.ThinkingWithTypes4 where

import Data.Coerce (Coercible(..), coerce)
import Data.Foldable (toList)
import qualified Data.Map as M
import Data.Monoid (Sum (..), Product (..))



-- | coerce - reinterpret cast
--   for example 
--          [a] <=> ZipList a   <- the same physical representation (newtype)
--
--  Coersible - magic typeclass which is generated by compiler


slowSum :: [Int] -> Int
slowSum = getSum . mconcat . fmap Sum

fastSum :: [Int] -> Int
fastSum = getSum . mconcat . coerce  -- coerce from [Int] to [Sum Int]





-- |
--  Map k v    and   Map (ReverseOrd k) v     - isn't coersible 
--   but
--  Mar k v    and   Map k (AnyNewType)       - is
--
-- nominal role           - k - never coersible
-- representational role  - v - can be coersible
-- phantom                - a from Proxy a - Proxy a   coersible to   Proxy b

data BST v = Empty | Branch (BST v) v (BST v)

type role BST nominal